import { Callout } from 'nextra/components'

# Entities

In Dreamlab, an entity is a distinct object that can be created, updated, or destroyed.
They can respond to events such as physics ticks or network packets and run logic in the game world.

<Callout>
  You will most likely not want to work with Entities directly. Dreamlab has an
  abstraction called Spawnable Entities that you should use to represent objects
  in the world.
</Callout>

## Spawnable Entities

Spawnable Entities are an abstraction on top of Entities that have stricter requirements.
They must have a position in the world, they must be able to be created and destroyed at runtime, and they must be able to be synced over the network.

### Defining

<Callout>
  The export `z` from `@dreamlab.gg/core/sdk` is actually a re-export of
  [Zod](https://zod.dev). Refer to their documentation for more info on how to
  define arguments.
</Callout>

```ts filename="TypeScript"
import { createSpawnableEntity } from '@dreamlab.gg/core'
import { z } from '@dreamlab.gg/core/sdk'

// Define the arguments for this entity
const ArgsSchema = z.object({})

const createExampleEntity = createSpawnableEntity(ArgsSchema, context => ({
  // ... implement all required members
}))
```

{/* TODO: Add docs on how data dependencies work */}

### Registering

Spawnable Entities must be registered with the `game` instance in order for them to be created by name.
This is most commonly done inside of a `sharedInit()` function, which is a convention that world scripts use to run initialization code on both client and server.

<Callout>
  Refer to your world scripts for how `sharedInit()` relates to the
  initialization of a world.
</Callout>

Entity names registered with the game instance **must be unique**. To avoid collisions, you should namespace your entity names as shown below.
Although we recommend namespacing using the `@project/entity` format, this is just a convention and you are free to solve uniqueness issues however you like.

```ts filename="shared.ts"
export const sharedInit = async game => {
  // register your entity with the game
  game.register('@example/example-entity', createExampleEntity)
}
```

### Spawning

{/* TODO: Write better copy */}

#### required

- `entity`
- `args`
- `transform.position`

#### optional

- `transform.rotation` / `0`
- `transform.zIndex` / `0`
- `uid` / `random cuid`
- `label`
- `tags` / `[]`

```ts filename="server.ts"
import type { InitServer } from '@dreamlab.gg/core/sdk'

export const init: InitServer = game => {
  // ... server-side initialization

  await game.spawn({
    // Reference the entity we registered by name
    entity: '@example/example-entity',

    // TODO
    args: {},

    // TODO
    transform: {
      position: [],
      rotation: 0,
      zIndex: 0,
    },

    // TODO
    tags: [],
  })
}
```

### Lifecycle

{/* TODO: Flesh out */}

- `init` -> called on spawn, client & server
- `initRenderContext` -> called after init, client only
- `onArgsUpdate` -> called when args change, client & server
- `onResize` -> called from `game.resize()`
- `onPhysicsStep` -> called every physics step, client & server
- `onRenderFrame` -> called every frame, client only
- `teardownRenderContext` -> called on destroy, client only
- `teardown` -> called after `teardownRenderContext`, client & server

---

## Example 1 - Bouncing Ball

This is a simple 2D bouncing ball.

```ts filename="TypeScript"
import { createSpawnableEntity } from '@dreamlab.gg/core'
import { Vec, toDegrees, toRadians } from '@dreamlab.gg/core/math'
import { drawCircle } from '@dreamlab.gg/core/utils'
import Matter from 'matter-js'
import { Graphics } from 'pixi.js'

export const createTestBall = createSpawnableEntity(
  ({ transform, zIndex, tags, preview }, radius) => {
    // Every object gets a transform automatically, this hold position and rotation information.
    const { position, rotation } = transform

    const mass = 20

    // Create our bouncy ball's physics body.
    const body = Matter.Bodies.circle(position.x, position.y, radius, {
      label: 'testBall',
      render: { visible: false },
      angle: toRadians(rotation),
      // the "preview" variable is true if the object isn't placed in the world yet but is a floating preview.
      // This is used to make your object compatible with the in-game level editor, so it doesn't collide while a preview.
      isStatic: preview,
      isSensor: preview,

      mass,
      inverseMass: 1 / mass,
      // The bounciness of the ball.
      restitution: 0.95,

      // You can also set initial inertia but we don't for this example.
      // inertia: Number.POSITIVE_INFINITY,
      // inverseInertia: 0,
    })

    return {
      get transform() {
        return {
          position: Vec.clone(body.position),
          rotation: toDegrees(body.angle),
        }
      },

      // Tags are used to identify certain entity types. For example, "enemy", "hpPowerUp", etc.
      // these are similar to Tags in Unity
      get tags() {
        return tags
      },

      // Determine whether the camera should render this entity.
      isInBounds(position) {
        return Matter.Query.point([body], position).length > 0
      },

      // Run when the entity is first initialized on the client or the server.
      init({ game, physics }) {
        const debug = game.debug
        physics.register(this, body)

        return { debug, physics, body }
      },

      // Run when the entity is initialized ONLY on the client.
      initRenderContext(_, { stage, camera }) {
        const gfx = new Graphics()
        gfx.zIndex = zIndex + 1
        drawCircle(gfx, { radius })

        stage.addChild(gfx)

        return { camera, gfx }
      },

      // Run when entity is destroyed.
      teardown({ physics, body }) {
        physics.unregister(this, body)
      },
      // Run when entity is destroyed, only run on client.
      teardownRenderContext({ gfx }) {
        gfx.destroy()
      },

      onRenderFrame(_, { body }, { camera, gfx }) {
        // Get the position of the entity relative to the camera.
        const pos = Vec.add(body.position, camera.offset)
        // update the position and rotation in screen space terms.
        gfx.position = pos
        gfx.rotation = body.angle
        gfx.alpha = 1
      },
    }
  },
)
```

### Spawning Entities

For this example, we want our bouncy ball to be synced between the client and server and also spawn over time.

```ts filename="TypeScript"
import { sharedInit } from './shared.js'

function randInt(min, max) {
  return Math.floor(Math.random() * (max - min)) + min
}

/** @type {import('@dreamlab.gg/core/sdk').InitServer} */
export const init = async game => {
  await sharedInit(game)

  // Spawn 50 balls, one per second.
  for (let i = 0; i < 50; i++) {
    setTimeout(() => {
      game.spawn({
        entity: 'testBall',
        // Give the ball a random radius between 20 and 150.
        // This is the "radius" positional argument on createTestBall
        args: [randInt(20, 150)],
        // Spawn the ball at a random x coordinate between -600 and 600
        transform: { position: [randInt(-600, 600), -700] },
        // Give the ball a "net/replicated" tag to automatically sync it between clients
        tags: ['net/replicated'],
      })
    }, i * 1000)
  }
}
```

These are the results when connecting on two clients. Notice the physics simulation is seamlessly synced:

<video
  style={{ width: '100%' }}
  controls
  src='/video/testBall demo.mp4'
></video>

## Example 2 - Mob with Health Bar

Suppose we want to create a mob which players using the default character controller can attack.
TODO: Finish
