"use strict";(self.webpackChunkdreamlab_docs=self.webpackChunkdreamlab_docs||[]).push([[578],{3905:(e,n,t)=>{t.d(n,{Zo:()=>p,kt:()=>h});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var l=r.createContext({}),c=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=c(e.components);return r.createElement(l.Provider,{value:n},e.children)},d="mdxType",m={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,a=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=c(t),u=i,h=d["".concat(l,".").concat(u)]||d[u]||m[u]||a;return t?r.createElement(h,o(o({ref:n},p),{},{components:t})):r.createElement(h,o({ref:n},p))}));function h(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var a=t.length,o=new Array(a);o[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[d]="string"==typeof e?e:i,o[1]=s;for(var c=2;c<a;c++)o[c]=t[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},2058:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var r=t(7462),i=(t(7294),t(3905));const a=t.p+"assets/medias/testBall demo-d7a68ab9f13af9d66bda7dfd9ddee200.mp4",o={sidebar_position:1},s="Entities",l={unversionedId:"concepts/entities",id:"concepts/entities",title:"Entities",description:"In Dreamlab, entities are any object in the world. They can move, have physics and colliders, render sprites, and more.",source:"@site/docs/concepts/entities.mdx",sourceDirName:"concepts",slug:"/concepts/entities",permalink:"/concepts/entities",draft:!1,editUrl:"https://github.com/WorldQL/dreamlab-docs/tree/trunk/docs/concepts/entities.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Concepts",permalink:"/category/concepts"},next:{title:"Animated Sprites",permalink:"/concepts/animated-sprites"}},c={},p=[{value:"Example 1 - Bouncing Ball",id:"example-1---bouncing-ball",level:2},{value:"Registering Entities",id:"registering-entities",level:3},{value:"Spawning Entities",id:"spawning-entities",level:3},{value:"Example 2 - Mob with Health Bar",id:"example-2---mob-with-health-bar",level:2}],d={toc:p},m="wrapper";function u(e){let{components:n,...t}=e;return(0,i.kt)(m,(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"entities"},"Entities"),(0,i.kt)("p",null,"In Dreamlab, entities are any object in the world. They can move, have physics and colliders, render sprites, and more."),(0,i.kt)("p",null,"The best way to learn the anatomy of an entity is an example. Below are some sample entities of varying complexity."),(0,i.kt)("h2",{id:"example-1---bouncing-ball"},"Example 1 - Bouncing Ball"),(0,i.kt)("p",null,"This is a simple 2D bouncing ball."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { createSpawnableEntity } from '@dreamlab.gg/core'\nimport { Vec, toDegrees, toRadians } from '@dreamlab.gg/core/math'\nimport { drawCircle } from '@dreamlab.gg/core/utils'\nimport Matter from 'matter-js'\nimport { Graphics } from 'pixi.js'\n\nexport const createTestBall = createSpawnableEntity(\n  ({ transform, zIndex, tags, preview }, radius) => {\n    // Every object gets a transform automatically, this hold position and rotation information.\n    const { position, rotation } = transform\n\n    const mass = 20\n\n    // Create our bouncy ball's physics body.\n    const body = Matter.Bodies.circle(position.x, position.y, radius, {\n      label: 'testBall',\n      render: { visible: false },\n      angle: toRadians(rotation),\n      // the \"preview\" variable is true if the object isn't placed in the world yet but is a floating preview.\n      // This is used to make your object compatible with the in-game level editor, so it doesn't collide while a preview.\n      isStatic: preview,\n      isSensor: preview,\n\n      mass,\n      inverseMass: 1 / mass,\n      // The bounciness of the ball.\n      restitution: 0.95,\n\n      // You can also set initial inertia but we don't for this example.\n      // inertia: Number.POSITIVE_INFINITY,\n      // inverseInertia: 0,\n    })\n\n    return {\n      get transform() {\n        return {\n          position: Vec.clone(body.position),\n          rotation: toDegrees(body.angle),\n        }\n      },\n\n      // Tags are used to identify certain entity types. For example, \"enemy\", \"hpPowerUp\", etc.\n      // these are similar to Tags in Unity\n      get tags() {\n        return tags\n      },\n\n      // Determine whether the camera should render this entity.\n      isInBounds(position) {\n        return Matter.Query.point([body], position).length > 0\n      },\n\n      // Run when the entity is first initialized on the client or the server.\n      init({ game, physics }) {\n        const debug = game.debug\n        physics.register(this, body)\n\n        return { debug, physics, body }\n      },\n\n      // Run when the entity is initialized ONLY on the client.\n      initRenderContext(_, { stage, camera }) {\n        const gfx = new Graphics()\n        gfx.zIndex = zIndex + 1\n        drawCircle(gfx, { radius })\n\n        stage.addChild(gfx)\n\n        return { camera, gfx }\n      },\n\n      // Run when entity is destroyed.\n      teardown({ physics, body }) {\n        physics.unregister(this, body)\n      },\n      // Run when entity is destroyed, only run on client.\n      teardownRenderContext({ gfx }) {\n        gfx.destroy()\n      },\n\n      onRenderFrame(_, { body }, { camera, gfx }) {\n        // Get the position of the entity relative to the camera.\n        const pos = Vec.add(body.position, camera.offset)\n        // update the position and rotation in screen space terms.\n        gfx.position = pos\n        gfx.rotation = body.angle\n        gfx.alpha = 1\n      },\n    }\n  },\n)\n")),(0,i.kt)("h3",{id:"registering-entities"},"Registering Entities"),(0,i.kt)("p",null,"All entities need to be registered with the Dreamlab engine before they can be used. This is done in the ",(0,i.kt)("inlineCode",{parentName:"p"},"sharedInit")," function that runs on both the client and the server."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"export const sharedInit = async game => {\n  // register testBall\n  game.register('testBall', createTestBall)\n  // spawn the rest of our predefined level\n  await game.spawnMany(...level)\n}\n")),(0,i.kt)("h3",{id:"spawning-entities"},"Spawning Entities"),(0,i.kt)("p",null,"For this example, we want our bouncy ball to be synced between the client and server and also spawn over time."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"import { sharedInit } from './shared.js'\n\nfunction randInt(min, max) {\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n\n/** @type {import('@dreamlab.gg/core/sdk').InitServer} */\nexport const init = async game => {\n  await sharedInit(game)\n\n  // Spawn 50 balls, one per second.\n  for (let i = 0; i < 50; i++) {\n    setTimeout(() => {\n      game.spawn({\n        entity: 'testBall',\n        // Give the ball a random radius between 20 and 150.\n        // This is the \"radius\" positional argument on createTestBall\n        args: [randInt(20, 150)],\n        // Spawn the ball at a random x coordinate between -600 and 600\n        transform: { position: [randInt(-600, 600), -700] },\n        // Give the ball a \"net/replicated\" tag to automatically sync it between clients \n        tags: ['net/replicated'],\n      })\n    }, i * 1000);\n  }\n}\n")),(0,i.kt)("p",null,"These are the results when connecting on two clients. Notice the physics simulation is seamlessly synced:"),(0,i.kt)("video",{style:{width:"100%"},controls:!0,src:a}),(0,i.kt)("h2",{id:"example-2---mob-with-health-bar"},"Example 2 - Mob with Health Bar"),(0,i.kt)("p",null,"Suppose we want to create a mob which players using the default character controller can attack.\nTODO: Finish"))}u.isMDXComponent=!0}}]);